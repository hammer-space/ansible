---
# Build RAID arrays for a single NUMA node with optional splitting
# Called from build_raid_arrays.yml with current_numa variable

- name: Get drives for NUMA node {{ current_numa }}
  ansible.builtin.set_fact:
    numa_drives: "{{ nvme_by_numa[current_numa] | default([]) }}"
    numa_leftover_drives: []

- name: Skip if not enough drives on NUMA {{ current_numa }}
  ansible.builtin.debug:
    msg: "Skipping NUMA {{ current_numa }}: only {{ numa_drives | length }} drives (minimum: {{ raid_min_drives_per_array | default(2) }})"
  when: numa_drives | length < (raid_min_drives_per_array | default(2))

- name: Process NUMA node {{ current_numa }} drives
  when: numa_drives | length >= (raid_min_drives_per_array | default(2))
  block:
    - name: Calculate max drives per array
      ansible.builtin.set_fact:
        effective_max_drives: "{{ raid_max_drives_per_array | default(0) | int }}"

    - name: Set unlimited if max is 0
      ansible.builtin.set_fact:
        effective_max_drives: "{{ numa_drives | length }}"
      when: effective_max_drives | int == 0

    - name: Apply power of 2 constraint to max drives
      ansible.builtin.set_fact:
        effective_max_drives: "{{ [1,2,4,8,16,32,64] | select('le', effective_max_drives | int) | list | last }}"
      when: raid_power_of_2_drives | default(false)

    - name: Calculate drives to use and leftovers
      ansible.builtin.set_fact:
        num_full_arrays: "{{ (numa_drives | length) // (effective_max_drives | int) }}"
        leftover_count: "{{ (numa_drives | length) % (effective_max_drives | int) }}"

    - name: Identify leftover drives
      ansible.builtin.set_fact:
        numa_leftover_drives: "{{ numa_drives[(num_full_arrays | int * effective_max_drives | int):] }}"
      when: leftover_count | int > 0

    # Build full-sized arrays
    - name: Build full RAID arrays for NUMA {{ current_numa }}
      ansible.builtin.set_fact:
        discovered_raid_arrays: >-
          {{
            discovered_raid_arrays | default([]) + [{
              'name': 'md' + ((discovered_raid_arrays | default([]) | length) | string),
              'device': '/dev/md' + ((discovered_raid_arrays | default([]) | length) | string),
              'level': raid_level | default(0),
              'numa_node': current_numa | int,
              'drives': numa_drives[((item | int) * (effective_max_drives | int)):((item | int + 1) * (effective_max_drives | int))]
            }]
          }}
      loop: "{{ range(0, num_full_arrays | int) | list }}"

    # Handle leftover drives based on strategy
    # Option: add_last - Add leftovers to the last array
    - name: Add leftover drives to last array
      ansible.builtin.set_fact:
        discovered_raid_arrays: >-
          {{
            discovered_raid_arrays[:-1] + [{
              'name': discovered_raid_arrays[-1].name,
              'device': discovered_raid_arrays[-1].device,
              'level': discovered_raid_arrays[-1].level,
              'numa_node': discovered_raid_arrays[-1].numa_node,
              'drives': discovered_raid_arrays[-1].drives + numa_leftover_drives
            }]
          }}
      when:
        - raid_leftover_drives | default('skip') == 'add_last'
        - numa_leftover_drives | length > 0
        - discovered_raid_arrays | length > 0

    # Option: separate - Create separate array for leftovers
    - name: Create separate array for leftover drives
      ansible.builtin.set_fact:
        discovered_raid_arrays: >-
          {{
            discovered_raid_arrays | default([]) + [{
              'name': 'md' + ((discovered_raid_arrays | default([]) | length) | string),
              'device': '/dev/md' + ((discovered_raid_arrays | default([]) | length) | string),
              'level': raid_level | default(0),
              'numa_node': current_numa | int,
              'drives': numa_leftover_drives
            }]
          }}
      when:
        - raid_leftover_drives | default('skip') == 'separate'
        - numa_leftover_drives | length >= (raid_min_drives_per_array | default(2))

    # Option: individual - Mount leftovers individually
    - name: Add leftover drives as individual mounts
      ansible.builtin.set_fact:
        discovered_individual_drives: >-
          {{
            discovered_individual_drives | default([]) + [{
              'device': item,
              'numa_node': current_numa | int
            }]
          }}
      loop: "{{ numa_leftover_drives }}"
      when:
        - raid_leftover_drives | default('skip') == 'individual'
        - numa_leftover_drives | length > 0

    # Report skipped drives
    - name: Report skipped leftover drives
      ansible.builtin.debug:
        msg: "NUMA {{ current_numa }}: {{ numa_leftover_drives | length }} leftover drive(s) skipped: {{ numa_leftover_drives | join(', ') }}"
      when:
        - raid_leftover_drives | default('skip') == 'skip'
        - numa_leftover_drives | length > 0

- name: Debug NUMA {{ current_numa }} processing
  ansible.builtin.debug:
    msg: |
      NUMA {{ current_numa }}: {{ numa_drives | length }} drives
        Full arrays: {{ num_full_arrays | default(0) }} x {{ effective_max_drives | default('all') }} drives
        Leftover drives: {{ numa_leftover_drives | length }} ({{ raid_leftover_drives | default('skip') }})
  when: numa_drives | length >= (raid_min_drives_per_array | default(2))
