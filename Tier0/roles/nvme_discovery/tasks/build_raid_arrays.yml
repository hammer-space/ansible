---
# Build RAID Arrays based on configuration options
# Supports: max drives per array, min drives, grouping strategies, power of 2

- name: Initialize RAID building variables
  ansible.builtin.set_fact:
    discovered_raid_arrays: []
    raid_array_counter: 0

# ============================================================================
# Strategy: per_drive - Each drive as separate mount (no RAID)
# ============================================================================
- name: Build per-drive configuration (no RAID)
  when: raid_grouping_strategy | default('numa') == 'per_drive'
  block:
    - name: Create mount point for each drive
      ansible.builtin.set_fact:
        discovered_mount_points: >-
          {{
            discovered_mount_points | default([]) + [{
              'path': mount_base_path | default('/hammerspace') + '/hsvol' + (loop_index | string),
              'device': item.device,
              'fstype': 'xfs',
              'label': 'hsvol' + (loop_index | string),
              'mount_opts': 'defaults,nofail,discard',
              'is_raid': false
            }]
          }}
      loop: "{{ nvme_devices }}"
      loop_control:
        index_var: loop_index

    - name: Skip RAID creation for per_drive strategy
      ansible.builtin.debug:
        msg: "Using per-drive strategy: {{ nvme_devices | length }} individual mounts (no RAID)"

# ============================================================================
# Strategy: single - One RAID across all drives (ignore NUMA)
# ============================================================================
- name: Build single RAID configuration
  when: raid_grouping_strategy | default('numa') == 'single'
  block:
    - name: Get all drives for single RAID
      ansible.builtin.set_fact:
        all_drives: "{{ nvme_devices | map(attribute='device') | list }}"

    - name: Apply power of 2 alignment for single RAID
      ansible.builtin.set_fact:
        all_drives: "{{ all_drives[:([1,2,4,8,16,32,64] | select('le', all_drives | length) | list | last)] }}"
      when: raid_power_of_2_drives | default(false)

    - name: Create single RAID array
      ansible.builtin.set_fact:
        discovered_raid_arrays:
          - name: md0
            device: /dev/md0
            level: "{{ raid_level | default(0) }}"
            numa_node: -1
            drives: "{{ all_drives }}"
      when: all_drives | length >= (raid_min_drives_per_array | default(2))

    - name: Display single RAID configuration
      ansible.builtin.debug:
        msg: "Using single RAID strategy: 1 array with {{ all_drives | length }} drives"

# ============================================================================
# Strategy: numa - Group by NUMA node with optional splitting
# ============================================================================
- name: Build NUMA-aware RAID configuration
  when: raid_grouping_strategy | default('numa') == 'numa'
  block:
    - name: Process each NUMA node
      ansible.builtin.include_tasks: build_numa_raids.yml
      loop: "{{ numa_nodes | map('string') | list }}"
      loop_control:
        loop_var: current_numa

# ============================================================================
# Build mount points for RAID arrays
# ============================================================================
- name: Build mount points for discovered RAID arrays
  ansible.builtin.set_fact:
    discovered_mount_points: >-
      {{
        discovered_mount_points | default([]) + [{
          'path': mount_base_path | default('/hammerspace') + '/hsvol' + (loop_index | string),
          'device': item.device,
          'fstype': 'xfs',
          'label': 'hsvol' + (loop_index | string),
          'mount_opts': 'defaults,nofail,discard',
          'is_raid': true
        }]
      }}
  loop: "{{ discovered_raid_arrays }}"
  loop_control:
    index_var: loop_index
  when:
    - raid_grouping_strategy | default('numa') != 'per_drive'
    - discovered_raid_arrays | length > 0

# ============================================================================
# Build mount points for individual leftover drives
# ============================================================================
- name: Build mount points for individual leftover drives
  ansible.builtin.set_fact:
    discovered_mount_points: >-
      {{
        discovered_mount_points | default([]) + [{
          'path': mount_base_path | default('/hammerspace') + '/hsvol' + ((discovered_mount_points | default([]) | length) | string),
          'device': item.device,
          'fstype': 'xfs',
          'label': 'hsvol' + ((discovered_mount_points | default([]) | length) | string),
          'mount_opts': 'defaults,nofail,discard',
          'is_raid': false,
          'numa_node': item.numa_node
        }]
      }}
  loop: "{{ discovered_individual_drives | default([]) }}"
  when:
    - raid_leftover_drives | default('skip') == 'individual'
    - discovered_individual_drives | default([]) | length > 0

- name: Display RAID array summary
  ansible.builtin.debug:
    msg: |
      ============================================
      RAID ARRAY CONFIGURATION
      ============================================
      Strategy: {{ raid_grouping_strategy | default('numa') }}
      Max drives per array: {{ raid_max_drives_per_array | default(0) | int }} (0=unlimited)
      Min drives per array: {{ raid_min_drives_per_array | default(2) }}
      Power of 2 alignment: {{ raid_power_of_2_drives | default(false) }}
      Leftover handling: {{ raid_leftover_drives | default('skip') }}
      RAID level: {{ raid_level | default(0) }}

      Arrays to create: {{ discovered_raid_arrays | length }}
      {% for array in discovered_raid_arrays %}
      {{ array.name }} ({{ array.device }}):
        NUMA Node: {{ array.numa_node }}
        RAID Level: {{ array.level }}
        Drives ({{ array.drives | length }}): {{ array.drives | join(', ') }}
      {% endfor %}

      Mount points: {{ discovered_mount_points | length }}
      {% for mp in discovered_mount_points %}
        {{ mp.path }} -> {{ mp.device }}{% if mp.is_raid is defined and not mp.is_raid %} (individual){% endif %}

      {% endfor %}
      {% if discovered_individual_drives | default([]) | length > 0 and raid_leftover_drives | default('skip') == 'individual' %}
      Individual drives (leftover): {{ discovered_individual_drives | length }}
      {% endif %}
      ============================================
