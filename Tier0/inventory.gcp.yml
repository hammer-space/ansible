---
# GCP Dynamic Inventory for Ansible
# Prerequisites:
#   ansible-galaxy collection install google.cloud
#   pip3 install google-auth requests
#   Configure GCP credentials
#
# Authentication options:
#   Option 1: Service account file
#     export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
#   Option 2: Application default credentials
#     gcloud auth application-default login
#   Option 3: Compute Engine default service account (when running on GCE)
#
# Test with: ansible-inventory -i inventory.gcp.yml --list

plugin: google.cloud.gcp_compute

# GCP Project(s) to query - REQUIRED: Update with your project ID
projects:
  - your-gcp-project-id
  # Add more projects as needed
  # - another-project-id

# Zones to query (leave empty to query all zones)
zones:
  - us-central1-a
  - us-central1-b
  - us-central1-c
  # Add more zones as needed
  # - us-west1-a
  # - us-west1-b

# Regions to query (alternative to zones - queries all zones in regions)
# regions:
#   - us-central1
#   - us-west1

# Authentication - choose one method
# Option 1: Service account file (recommended for automation)
# service_account_file: /path/to/service-account.json

# Option 2: Use application default credentials
auth_kind: application

# Option 3: Service account content directly (for CI/CD)
# service_account_contents: "{{ lookup('env', 'GCP_SERVICE_ACCOUNT_CONTENTS') }}"

# Filter to only running instances
# Uses GCP filter syntax: https://cloud.google.com/compute/docs/reference/rest/v1/instances/list
filters:
  - status = RUNNING
  # Filter by label - uncomment and adjust as needed
  # - labels.environment = tier0
  # - labels.role = storage
  # Filter by machine type (GPU instances)
  # - machineType = a2-highgpu-8g
  # - machineType = a2-ultragpu-8g

# Create storage_servers group based on labels
groups:
  storage_servers: "'tier0' in (labels.role | default('')) or 'storage' in (labels.role | default(''))"

# Set connection variables and expose GCP metadata
compose:
  ansible_host: networkInterfaces[0].networkIP
  ansible_user: "'ubuntu'"
  ansible_python_interpreter: "'/usr/bin/python3'"
  ansible_become: true
  # GCP metadata
  gcp_instance_name: name
  gcp_instance_id: id
  gcp_machine_type: machineType | basename
  gcp_zone: zone | basename
  gcp_region: zone | basename | regex_replace('-[a-z]$', '')
  gcp_network: networkInterfaces[0].network | basename
  gcp_subnetwork: networkInterfaces[0].subnetwork | basename
  gcp_private_ip: networkInterfaces[0].networkIP
  gcp_public_ip: networkInterfaces[0].accessConfigs[0].natIP | default('')
  gcp_status: status
  gcp_creation_timestamp: creationTimestamp
  gcp_labels: labels | default({})
  gcp_tags: tags.items | default([])
  # Disk information
  gcp_disks: disks | default([])
  gcp_boot_disk: disks | selectattr('boot', 'equalto', true) | first | default({})
  # CPU platform
  gcp_cpu_platform: cpuPlatform | default('')
  gcp_min_cpu_platform: minCpuPlatform | default('')
  # Scheduling
  gcp_preemptible: scheduling.preemptible | default(false)
  gcp_on_host_maintenance: scheduling.onHostMaintenance | default('')
  # Hammerspace AZ prefix derived from zone
  # us-central1-a -> "AZ1:", us-central1-b -> "AZ2:", us-central1-c -> "AZ3:", etc.
  hammerspace_volume_az_prefix: >-
    "AZ" ~ (((zone | basename)[-1:] | lower | ord) - 96) ~ ":"

# Create groups based on zone, machine type, and labels
keyed_groups:
  # Group by zone (e.g., zone_us-central1-a)
  - key: zone | basename
    prefix: zone
    separator: "_"
  # Group by region (e.g., region_us-central1)
  - key: zone | basename | regex_replace('-[a-z]$', '')
    prefix: region
    separator: "_"
  # Group by machine type (e.g., type_a2-highgpu-8g)
  - key: machineType | basename
    prefix: type
    separator: "_"
  # Group by environment label (e.g., env_production)
  - key: labels.environment | default('untagged')
    prefix: env
    separator: "_"
  # Group by network (e.g., network_default)
  - key: networkInterfaces[0].network | basename
    prefix: network
    separator: "_"
